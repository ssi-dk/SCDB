#' Sets, queries and removes locks for db tables
#'
#' @name db_locks
#' @description
#'   This set of function adds a simple locking system to db tables.
#'   * `add_table_lock()` adds a record in the schema.locks table with the current time and R-session process id.
#'   * `remove_table_lock()` removes records in the schema.locks table with the target table and the
#'      R-session process id.
#'   * `is_lock_owner()` returns `TRUE` if the current process id (pid) matches the pid associated with the lock on
#'      db_table in schema.locks. If no lock is found, `NULL` is returned.
#'   * `remove_expired_locks()` removes locks that are timed out or where the process owning the lock is exited.
#' @template conn
#' @param db_table (`character(1)`)\cr
#'   A specification of "schema.table" to modify lock for.
#' @param schema (`character(1)`)\cr
#'   The schema where the "locks" table should be created.
#' @return
#'   Most have return value (called for side effects).
#'   `is_lock_owner()` returns the TRUE if the process can modify the table.
#' @examples
#'   conn <- DBI::dbConnect(RSQLite::SQLite())
#'
#'   is_lock_owner(conn, "test_table") # NULL
#'
#'   add_table_lock(conn, "test_table")
#'   is_lock_owner(conn, "test_table") # TRUE
#'
#'   remove_table_lock(conn, "test_table")
#'   is_lock_owner(conn, "test_table") # NULL
#'
#'   DBI::dbDisconnect(conn)
#' @export
add_table_lock <- function(conn, db_table, schema = NULL) {
  checkmate::assert_class(conn, "DBIConnection")
  assert_id_like(db_table)
  checkmate::assert_character(schema, null.ok = TRUE)

  # Determine lock table id
  lock_table_id <- id(paste(c(schema, "locks"), collapse = "."), conn)

  # Create lock table if missing
  if (!table_exists(conn, lock_table_id)) {
    suppressMessages(
      dplyr::copy_to(conn,
                     data.frame("db_table" = character(0),
                                "lock_start" = numeric(0),
                                "pid" = numeric(0)),
                     lock_table_id, temporary = FALSE, unique_indexes = "db_table")
    )
  }

  # Get a reference to the table
  lock_table <- dplyr::tbl(conn, lock_table_id, check_from = FALSE)

  # We first delete old locks.
  remove_expired_locks(conn, schema)

  # We then try to insert a lock, if none exists, our process ID (pid) will be assigned to the table
  # if one already exists, our insert will fail.
  tryCatch(
    {
      lock <- dplyr::copy_to(
        conn,
        data.frame("db_table" = db_table, "pid" = Sys.getpid(), "lock_start" = as.numeric(Sys.time())),
        name = paste0("ds_lock_", Sys.getpid()),
        overwrite = TRUE
      )

      dplyr::rows_insert(lock_table, lock, by = "db_table", conflict = "ignore", in_place = TRUE)

    },
    error = function(e) {
      print(e$message)
    }
  )

  return(NULL)
}


#' @rdname db_locks
#' @export
remove_table_lock <- function(conn, db_table, schema = NULL) {
  checkmate::assert_class(conn, "DBIConnection")
  assert_id_like(db_table)
  checkmate::assert_character(schema, null.ok = TRUE)

  # Determine lock table id
  lock_table_id <- id(paste(c(schema, "locks"), collapse = "."), conn)

  # Create lock table if missing
  if (!table_exists(conn, lock_table_id)) {
    return(NULL)
  }

  # Get a reference to the table
  lock_table <- dplyr::tbl(conn, lock_table_id, check_from = FALSE)

  # Delete locks matching  our process ID (pid) and the given db_table
  tryCatch(
    {
      lock <- dplyr::copy_to(
        conn,
        data.frame("db_table" = db_table, "pid" = Sys.getpid()),
        name = paste0("ds_lock_", Sys.getpid()),
        overwrite = TRUE
      )

      dplyr::rows_delete(lock_table, lock, by = c("db_table", "pid"), unmatched = "ignore", in_place = TRUE)

    },
    error = function(e) {
      print(e$message)
    }
  )

  return(NULL)
}


#' @rdname db_locks
#' @export
is_lock_owner <- function(conn, db_table, schema = NULL) {
  checkmate::assert_class(conn, "DBIConnection")
  assert_id_like(db_table)
  checkmate::assert_character(schema, null.ok = TRUE)

  # Determine lock table id
  lock_table_id <- id(paste(c(schema, "locks"), collapse = "."), conn)

  # Create lock table if missing
  if (!table_exists(conn, lock_table_id)) {
    return(NULL)
  }

  # Get a reference to the table
  lock_owner <- dplyr::tbl(conn, lock_table_id, check_from = FALSE) |>
    dplyr::filter(.data$db_table == !!db_table) |>
    dplyr::pull("pid") |>
    as.integer()

  return(lock_owner == Sys.getpid())
}


#' @rdname db_locks
#' @param lock_wait_max (`numeric(1)`)\cr
#'   The number of seconds to wait before marking lock as expired.
#' @importFrom rlang .data
#' @import parallelly
#' @export
remove_expired_locks <- function(conn, schema = NULL, lock_wait_max = getOption("SCDB.lock_wait_max")) {
  checkmate::assert_class(conn, "DBIConnection")
  checkmate::assert_character(schema, null.ok = TRUE)
  checkmate::assert_number(lock_wait_max, null.ok = TRUE)

  # Determine lock table id
  lock_table_id <- id(paste(c(schema, "locks"), collapse = "."), conn)

  # Return early if missing
  if (!table_exists(conn, lock_table_id)) {
    return(NULL)
  }

  # Get a reference to the table
  lock_table <- dplyr::tbl(conn, lock_table_id, check_from = FALSE)

  # Attempt to get the un-exported pid_exists() from parallelly
  pid_exists <- tryCatch(
    utils::getFromNamespace("pid_exists", "parallelly"),
    error = function(e) FALSE
  )


  # If pid_exists is not available and lock_wait_max is NULL, we cannot determine invalid locks
  # and we throw an error to prevent infinite looping
  checkmate::assert(
    checkmate::check_function(pid_exists),
    checkmate::check_number(lock_wait_max, lower = 0, finite = TRUE)
  )

  ## Remove expired locks
  if (!is.null(lock_wait_max)) {
    expired_locks <- lock_table |>
      dplyr::filter(.data$lock_start < !!as.numeric(Sys.time()) - lock_wait_max) |>
      dplyr::select("schema", "table")

    dplyr::rows_delete(lock_table, expired_locks, by = c("schema", "table"), unmatched = "ignore", in_place = TRUE)
  }

  ## Remove orphaned locks from crashed processes
  if (is.function(pid_exists)) {
    # Determine orphaned locks
    crashed_pids <- lock_table |>
      dplyr::distinct("pid") |>
      dplyr::filter(.data$pid != Sys.getpid()) |>
      dplyr::pull("pid") |>
      purrr::discard(pid_exists)

    # Remove orphaned locks
    crashed_locks <- lock_table |>
      dplyr::filter(.data$pid %in% crashed_pids)
    dplyr::rows_delete(lock_table, crashed_locks, by = "db_table", unmatched = "ignore", in_place = TRUE)
  }

  return(NULL)
}
