# dbplyr needs additional implementation for Oracle to work.

#' @importClassesFrom RJDBC JDBCConnection
#' @importClassesFrom odbc Oracle
setClass(
  "OracleJdbc",
  slots = list(
    "jdbc_conn" = "JDBCConnection",
    "servername" = "character",
    "options" = "list"
  ),
  contains = "Oracle"
)

#' @importClassesFrom RJDBC JDBCResult
setClass("OracleJdbcResult", contains = "Oracle")


# DBI methods defined in RJDBC package
# dbOption
# dbListConnections
# dbGetInfo
# dbUnloadDriver
# dbConnect
# dbDisconnect
# dbIsValid          - mapped
# dbSendQuery        - mapped
# dbSendUpdate
# dbGetQuery
# dbGetException
# dbGetInfo
# dbListResults
# dbListTables
# dbGetTables
# dbExistsTable      - mapped
# dbRemoveTable
# dbListFields
# dbGetFields
# dbReadTable
# dbReadTable
# dbDataType
# dbWriteTable       - mapped
# dbCommit
# dbRollback         - mapped
# dbBegin            - mapped
# dbClearResult
# dbGetInfo          - mapped
# dbHasCompleted
# dbColumnInfo

# Additonal implementations
# dbQuoteIdentifier
# dbSendStatement
# dbCollect

#' @export
db_collect.OracleJdbc <- function(con, sql, n = -1, ...) {
  dbGetQuery(con, sql, n, ...)
}


#' @importMethodsFrom DBI dbWriteTable
#' @importMethodsFrom RJDBC dbWriteTable
#' @exportMethod dbWriteTable
setMethod(
  "dbWriteTable",
  signature(
    conn = "OracleJdbc",
    name = "character",
    value = "data.frame"
  ),
  function(conn, name, value, ...) {
    DBI::dbWriteTable(conn@jdbc_conn, id(name, conn@jdbc_conn), value, ...)
  }
)

#' @importMethodsFrom DBI dbWriteTable
#' @importMethodsFrom RJDBC dbWriteTable
#' @exportMethod dbWriteTable
setMethod(
  "dbWriteTable",
  signature(
    conn = "OracleJdbc",
    name = "Id",
    value = "data.frame"
  ),
  function(conn, name, value, ...) {
    DBI::dbWriteTable(conn, DBI::dbQuoteIdentifier(conn@jdbc_conn, name), value, ...)
  }
)

#' @importMethodsFrom DBI dbWriteTable
#' @importMethodsFrom RJDBC dbWriteTable
#' @exportMethod dbWriteTable
setMethod(
  "dbWriteTable",
  signature(
    conn = "OracleJdbc",
    name = "SQL",
    value = "data.frame"
  ),
  function(conn, name, value, ...) {

    names(value) <- as.character(DBI::dbQuoteIdentifier(conn@jdbc_conn, names(value)))

    DBI::dbWriteTable(conn@jdbc_conn, name, value)
  }
)


# # The ANALYZE TABLE command generated by dplyr does not work for Oracle, so we manually implement.
# #' DBI::dbSendQuery@exportS3Method dbplyr::sql_table_analyze
# #' @noRd
# sql_table_analyze.Oracle <- function(con, table, ...) {
#   dbplyr::build_sql(
#     "ANALYZE TABLE ",
#     dbplyr::as.sql(id(table, conn = con), con = con),
#     " COMPUTE STATISTICS",
#     con = con
#   )
# }dbExistsTable

#' @importMethodsFrom DBI dbExistsTable
#' @importMethodsFrom RJDBC dbExistsTable
#' @exportMethod dbExistsTable
setMethod(
  "dbExistsTable",
  signature(
    conn = "OracleJdbc",
    name = "Id"
  ),
  function(conn, name, ...) {
    DBI::dbExistsTable(conn@jdbc_conn, name, ...)
  }
)

#' @importFrom rJava .jcall
#' @importMethodsFrom DBI dbGetRowsAffected
#' @exportMethod dbGetRowsAffected
#' @noRd
setMethod(
  "dbGetRowsAffected",
  signature(
    res = "JDBCResult"
  ),
  function(res, ...) {
    if (!is.null(res@stat)) {
      tryCatch({
        cnt <- rJava::.jcall(res@stat, "I", "getUpdateCount")
        return(if (cnt < 0) 0L else as.integer(cnt))
      }, error = function(e) {
        return(NA_integer_)
      })
    }
    return(NA_integer_)
  }
)

#' @importMethodsFrom DBI dbQuoteIdentifier
#' @exportMethod dbQuoteIdentifier
setMethod(
  "dbQuoteIdentifier",
  signature(
    conn = "OracleJdbc",
    x = "character"
  ),
  function(conn, x, ...) {
    x <- enc2utf8(x)

    reserved_words <- c("DATE", "NUMBER", "VARCHAR")

    needs_escape <- (grepl("^[a-zA-Z_]", x) & toupper(x) != x) |  tolower(x) %in% reserved_words

    x[needs_escape] <- paste0("\"", gsub("\"", "\"\"", x[needs_escape]), "\"")

    return(DBI::SQL(x, names = names(x)))
  }
)

#' @importMethodsFrom DBI dbQuoteIdentifier
#' @exportMethod dbQuoteIdentifier
setMethod(
  "dbQuoteIdentifier",
  signature(
    conn = "OracleJdbc",
    x = "SQL"
  ),
  function(conn, x, ...) {
    return(x) # Remove ambiguity (also assume already quoted)
  }
)

#' @importMethodsFrom DBI dbQuoteIdentifier
#' @exportMethod dbQuoteIdentifier
setMethod(
  "dbQuoteIdentifier",
  signature(
    conn = "OracleJdbc",
    x = "Id"
  ),
  function(conn, x, ...) {

    # For `Id`, run on each non-NA element
    return(DBI::SQL(paste0(DBI::dbQuoteIdentifier(conn@jdbc_conn, purrr::discard(x@name, is.na)), collapse = ".")))
  }
)



#' @importMethodsFrom DBI dbSendQuery
#' @importMethodsFrom RJDBC dbSendQuery
#' @exportMethod dbSendQuery
setMethod(
  "dbSendQuery",
  signature(
    conn = "OracleJdbc",
    statement = "character"
  ),
  function(conn, statement, ...) {
    DBI::dbSendQuery(conn@jdbc_conn, statement)
  }
)

#' @importMethodsFrom DBI dbIsValid
#' @exportMethod dbIsValid
setMethod(
  "dbIsValid",
  signature(
    dbObj = "OracleJdbc"
  ),
  function(dbObj, ...) {
    DBI::dbIsValid(dbObj@jdbc_conn, ...)
  }
)

#' @importMethodsFrom DBI dbBegin
#' @exportMethod dbBegin
setMethod(
  "dbBegin",
  signature(
    conn = "OracleJdbc"
  ),
  function(conn, ...) {
    DBI::dbBegin(conn@jdbc_conn, ...)
  }
)

#' @importMethodsFrom DBI dbRollback
#' @exportMethod dbRollback
setMethod(
  "dbRollback",
  signature(
    conn = "OracleJdbc"
  ),
  function(conn, ...) {
    DBI::dbRollback(conn@jdbc_conn, ...)
  }
)

#' @importMethodsFrom DBI dbCommit
#' @exportMethod dbCommit
setMethod(
  "dbCommit",
  signature(
    conn = "OracleJdbc"
  ),
  function(conn, ...) {
    DBI::dbCommit(conn@jdbc_conn, ...)
  }
)

#' @importMethodsFrom DBI dbGetInfo
#' @exportMethod dbGetInfo
setMethod(
  "dbGetInfo",
  signature(
    dbObj = "OracleJdbc"
  ),
  function(dbObj, ...) {
    modifyList(
      DBI::dbGetInfo(dbObj@jdbc_conn, ...),
      list(
        "servername" = dbObj@servername,
        "port" = ""
      )
    )
  }
)

#' @importMethodsFrom DBI dbSendStatement
#' @exportMethod dbSendStatement
setMethod(
  "dbSendStatement",
  signature(
    conn = "OracleJdbc",
    statement = "character"
  ),
  function(conn, statement, ...) {
    DBI::dbSendQuery(conn@jdbc_conn, statement, ...)
  }
)

#' @importMethodsFrom DBI dbFetch
#' @exportMethod dbFetch
setMethod(
  "dbFetch",
  signature(
    res = "OracleJdbcResult",
    n = "numeric"
  ),
  function(res, n, ...) {
    rjdbc_fetch(res, n, ...)
  }
)

#' @importMethodsFrom DBI fetch
#' @exportMethod fetch
setMethod(
  "fetch",
  signature(
    res = "OracleJdbcResult"
  ),
  function(res, ...) {
    rjdbc_fetch(res, ...)
  }
)


# RJDBC has seemingly stopped active development but their latest version of
# `fetch` is needed to retreive results from oracle in a meaningful manor.
# We implement a minimal version of that function here
rjdbc_fetch <- function(
  res,
  n,
  block = 2048L,
  ...
) {

  cols <- rJava::.jcall(res@md, "I", "getColumnCount")
  block <- as.integer(block)
  if (length(block) != 1L) stop("invalid block size")
  if (cols < 1L) return(NULL)
  l <- vector("list", cols)
  cts <- rep(0L, cols) ## column type (as per JDBC)
  rts <- rep(0L, cols) ## retrieval types (0 = string, 1 = double, 2 = integer, 3 = POSIXct)
  for (i in 1:cols) {
    ## possible retrieval:
    ## getDouble(), getTimestamp() and getString()
    ## [NOTE: getBigDecimal() is native for all numeric() types]
    ## could cehck java.sql.Timestamp which has .getTime() in millis
    cts[i] <- ct <- rJava::.jcall(res@md, "I", "getColumnType", i)
    l[[i]] <- character()
    ## NOTE: this is also needed in dbColumnInfo() - see also JDBC.types
    ## -7 BIT, -6 TINYINT, 5 SMALLINT, 4 INTEGER, -5 BIGINT
    ## 6 FLOAT, 7 REAL, 8 DOUBLE, 2 NUMERIC, 3 DECIMAL
    ## 1 CHAR, 12 VARCHAR, -1 LONGVARCHAR
    ## 91 DATE, 92 TIME, 93 TIMESTAMP
    ## -2 BINARY, -3 VARBINARY, -4 LONGVARBINARY
    ## 0 NULL, 1111 OTHER, 2000 JAVA_OBJECT
    ## 16 BOOLEAN, 1.8+: 2013 TIME_WITH_TIMEZONE,
    ## 2014 TIMESTAMP_WITH_TIMEZONE
    ##
    ## integer-compatible typse
    if (ct == 4L || ct == 5L || ct == -6L) {
      l[[i]] <- integer()
      rts[i] <- 2L
    } else if (ct == -5L || (ct >= 2L && ct <= 8L)) { ## BIGINT and various float/num types
      ## some numeric types may exceed double precision (see #83)
      ## those must be retrieved as strings
      ##
      ## check precision for NUMERIC/DECIMAL
      cp <- switch(
        as.character(ct),
        `2`  = rJava::.jcall(res@md, "I", "getPrecision", i),
        `3`  = rJava::.jcall(res@md, "I", "getPrecision", i),
        `-5` = 20L, ## BIGINT
        0L
      )

      l[[i]] <- numeric()
      rts[i] <- 1L

    } else if (ct >= 91L && ct <= 93L) { ## DATE/TIME/TS
      l[[i]] <- as.POSIXct(numeric())
      rts[i] <- 3L
    } else if (ct == -7L) { ## BIT
      l[[i]] <- logical()
      rts[i] <- 4L
    }
    names(l)[i] <- rJava::.jcall(res@md, "S", "getColumnLabel", i)
  }

  rp <- res@env$pull
  if (rJava::is.jnull(rp)) {
    rp <- rJava::.jnew(
      "info/urbanek/Rpackage/RJDBC/JDBCResultPull",
      rJava::.jcast(res@jr, "java/sql/ResultSet"),
      rJava::.jarray(as.integer(rts))
    )
    res@env$pull <- rp
  }

  ret_fn <- list( ## retrieval functions for the different types
    function(i) rJava::.jcall(rp, "[Ljava/lang/String;", "getStrings", i),
    function(i) rJava::.jcall(rp, "[D", "getDoubles", i),
    function(i) rJava::.jcall(rp, "[I", "getIntegers", i),
    function(i) rJava::.jcall(rp, "[D", "getDoubles", i),
    function(i) as.logical(rJava::.jcall(rp, "[I", "getIntegers", i))
  )

  if (n < 0L) { ## infinite pull - collect (using pairlists) & join
    stride <- 32768L  ## start fairly small to support tiny queries and increase later
    while ((nrec <- rJava::.jcall(rp, "I", "fetch", stride, block)) > 0L) {
      for (i in seq.int(cols)) {
        l[[i]] <- pairlist(l[[i]], ret_fn[[rts[i] + 1L]](i))
      }
      if (nrec < stride) break
      stride <- 524288L # 512k
    }
    for (i in seq.int(cols)) l[[i]] <- unlist(l[[i]], TRUE, FALSE)
  } else {
    nrec <- rJava::.jcall(rp, "I", "fetch", as.integer(n), block)
    for (i in seq.int(cols)) l[[i]] <- ret_fn[[rts[i] + 1L]](i)
  }
  ## unlisting can strip attrs so do POSIXct at the end for TSs
  ts_col <- rts == 3L
  if (any(ts_col)) for (i in which(ts_col)) l[[i]] <- as.POSIXct(l[[i]])
  # as.data.frame is expensive - create it on the fly from the list
  attr(l, "row.names") <- c(NA_integer_, length(l[[1]]))
  class(l) <- "data.frame"
}
