# dbplyr needs additional implementation for Oracle to work.

#' @importMethodsFrom DBI dbExistsTable
#' @importMethodsFrom RJDBC dbExistsTable
#' @importMethodsFrom DBI dbGetRowsAffected
#' @importMethodsFrom DBI dbQuoteIdentifier
#' @importMethodsFrom DBI dbWriteTable
#' @importMethodsFrom RJDBC dbWriteTable
NULL


#' @exportMethod dbWriteTable
setMethod("dbWriteTable", signature("Oracle", "character", "data.frame"),
          function(conn, name, value, ...) {
            DBI::dbWriteTable(conn@conn, id(conn@conn, name), value, ...)
          }
)

#' @exportMethod dbWriteTable
setMethod("dbWriteTable", signature("Oracle", "Id", "data.frame"),
          function(conn, name, value, ...) {
            DBI::dbWriteTable(conn, DBI::dbQuoteIdentifier(conn@conn, name), value, ...)
          }
)


# # The ANALYZE TABLE command generated by dplyr does not work for Oracle, so we manually implement.
# #' @exportS3Method dbplyr::sql_table_analyze
# #' @noRd
# sql_table_analyze.Oracle <- function(con, table, ...) {
#   dbplyr::build_sql(
#     "ANALYZE TABLE ",
#     dbplyr::as.sql(id(table, conn = con), con = con),
#     " COMPUTE STATISTICS",
#     con = con
#   )
# }

#' @exportMethod dbExistsTable
setMethod("dbExistsTable", signature("dbExistsTable", "Id"),
          function(conn, name, ...) {
            DBI::dbExistsTable(conn@conn, name, ...)
          }
)


# #' @importFrom rJava .jcall
# #' @importFrom methods setMethod
# #' @exportMethod dbGetRowsAffected
# #' @noRd
# setMethod("dbGetRowsAffected", "Oracle", function(res, ...) {
#   if (!is.null(res@stat)) {
#     tryCatch({
#       cnt <- rJava::.jcall(res@stat, "I", "getUpdateCount")
#       return(if (cnt < 0) 0L else as.integer(cnt))
#     }, error = function(e) {
#       return(NA_integer_)
#     })
#   }
#   return(NA_integer_)
# })

# #' @exportMethod dbQuoteIdentifier
# #' @noRd
# setMethod("dbQuoteIdentifier", signature("Oracle", "character"),
#           function(conn, x, ...) {
#             x <- enc2utf8(x)

#             reserved_words <- c("DATE", "NUMBER", "VARCHAR")

#             needs_escape <- (grepl("^[a-zA-Z_]", x) & toupper(x) != x) |  tolower(x) %in% reserved_words

#             x[needs_escape] <- paste0("\"", gsub("\"", "\"\"", x[needs_escape]), "\"")

#             return(DBI::SQL(x, names = names(x)))
#           }
# )

# #' @exportMethod dbQuoteIdentifier
# #' @noRd
# setMethod("dbQuoteIdentifier", signature("Oracle", "SQL"),
#           function(conn, x, ...) {
#             return(x) # Remove ambiguity (also assume already quoted)
#           }
# )

# #' @exportMethod dbQuoteIdentifier
# #' @noRd
# setMethod("dbQuoteIdentifier", signature("Oracle", "Id"),
#           function(conn, x, ...) {

#             # For `Id`, run on each non-NA element
#             return(DBI::SQL(paste0(DBI::dbQuoteIdentifier(conn, purrr::discard(x@name, is.na)), collapse = ".")))
#           }
# )

#' @importFrom methods setMethod
#' @exportMethod dbWriteTable
#' @noRd
setMethod("dbWriteTable", signature("Oracle", "SQL", "data.frame"),
          function(conn, name, value, ...) {

            names(value) <- as.character(DBI::dbQuoteIdentifier(conn@conn, names(value)))

            DBI::dbWriteTable(conn@conn, name, value)
  }
)
