# dbplyr needs additional implementation for Oracle to work.

# The ANALYZE TABLE command generated by dplyr does not work for Oracle, so we manually implement.
#' @exportS3Method dbplyr::sql_table_analyze
sql_table_analyze.JDBCConnection <- function(con, table, ...) {
  dbplyr::build_sql(
    "ANALYZE TABLE ",
    dbplyr::as.sql(id(table, conn = con), con = con),
    " COMPUTE STATISTICS",
    con = con
  )
}

#' @importFrom DBI dbGetRowsAffected
NULL

#' @importFrom rJava .jcall
#' @exportMethod dbGetRowsAffected
setMethod("dbGetRowsAffected", "JDBCResult", function(res, ...) {
  if (!is.null(res@stat)) {
    tryCatch({
      cnt <- rJava::.jcall(res@stat, "I", "getUpdateCount")
      return(if (cnt < 0) 0L else as.integer(cnt))
    }, error = function(e) {
      return(NA_integer_)
    })
  }
  return(NA_integer_)
})


#' @importFrom DBI dbQuoteIdentifier
NULL

#' Quote identifiers for Oracle
#'
#' @param conn A JDBCConnection
#' @param x Character vector of identifiers to quote
#' @param ... Additional arguments (ignored)
#' @return SQL object with quoted identifiers
#' @exportMethod dbQuoteIdentifier
setMethod("dbQuoteIdentifier", signature("JDBCConnection"),
  function(conn, x, ...) {

    # Return early if no quoting needed
    if (is.null(x)) return(x)
    if (is(x, "SQL")) return(x)

    # For `Id`, run on each non-NA element
    if (is(x, "Id")) {
        return(DBI::SQL(paste0(dbQuoteIdentifier(conn, purrr::discard(x@name, is.na)), collapse = ".")))
    }

    if (any(is.na(x))) {
        stop("Cannot pass NA to dbQuoteIdentifier()")
    }

    if (is.character(x)) {
      x <- enc2utf8(x)

      reserved_words <- c("date", "number")

      needs_escape <- !grepl("^[a-zA-Z_][a-zA-Z0-9_]*$", x) | tolower(x) %in%
          c(conn@reserved_words, reserved_words)

      x[needs_escape] <- paste0("\"", gsub("\"", "\"\"", x[needs_escape]),
          "\"")

      DBI::SQL(x, names = names(x))
    }

    stop("Cannot quote object of class: ", class(x))
  }
)
