on:
  push


jobs:
  code-coverage-oracle:
    name: "ðŸ§ª Tests: Oracle Database (Experimental)"
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    services:
      oracledb:
        image: gvenzl/oracle-free:latest
        env:
          APP_USER: "github_ci"
          APP_USER_PASSWORD: "github_ci"
          ORACLE_PASSWORD: "github_ci"
        ports:
          - 1521:1521
        options: >-
          --health-cmd healthcheck.sh
          --health-interval 20s
          --health-timeout 10s
          --health-retries 10

    env:
      BACKEND: Oracle
      BACKEND_DRV: RJDBC::JDBC
      BACKEND_ARGS: ''
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: â¬‡ï¸ Checkout repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: ðŸ”§ Set environment variables
        run: |
          ORACLEHOST=localhost

          echo "ORACLEHOST=${ORACLEHOST}" >> $GITHUB_ENV

          CONN_ARGS_JSON="{
            \"Oracle\": {
              \"driverClass\": \"oracle.jdbc.OracleDriver\",
              \"classPath\": \"/usr/lib/oracle/ojdbc8.jar\",
              \"url\": \"jdbc:oracle:thin:@${ORACLEHOST}:1521/FREEPDB1\",
              \"user\": \"github_ci\",
              \"password\": \"github_ci\"
            }
          }"

          echo "CONN_ARGS_JSON<<EOF" >> $GITHUB_ENV
          echo $CONN_ARGS_JSON >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV


      - name: ðŸ”§ Install Oracle JDBC driver
        run: |
          sudo apt-get update
          # Create directory for the driver with sudo
          sudo mkdir -p /usr/lib/oracle

          # Download the Oracle JDBC driver directly from Maven Central with sudo
          sudo curl -o /usr/lib/oracle/ojdbc8.jar https://repo1.maven.org/maven2/com/oracle/database/jdbc/ojdbc8/21.5.0.0/ojdbc8-21.5.0.0.jar

          # Verify the driver was downloaded successfully
          if sudo test -f "/usr/lib/oracle/ojdbc8.jar"; then
            echo "Oracle JDBC driver downloaded successfully"
            sudo ls -la /usr/lib/oracle/
            # Make the JAR file readable by everyone
            sudo chmod 644 /usr/lib/oracle/ojdbc8.jar
          else
            echo "Failed to download Oracle JDBC driver"
            exit 1
          fi

      - name: ðŸ”§ Set up Oracle JDK
        uses: actions/setup-java@v5
        with:
          distribution: oracle
          java-version: 25

      - name: ðŸ”§ Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: 'release'
          use-public-rspm: true

      - name: ðŸ”§ Install R dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: |
            local::.
            any::pak
            any::jsonlite
            any::rcmdcheck
            any::devtools
            any::lintr
            any::covr
            any::roxygen2
            any::pkgdown
            any::rmarkdown
            any::styler
          needs: build, check, coverage, roxygen2, lint, website

      - name: ðŸ”§ Configure Java for R
        run: |
          # Create .Rprofile to automatically set Java classpath
          echo 'Sys.setenv(JAVA_HOME = Sys.getenv("JAVA_HOME"))' > ~/.Rprofile
          echo 'Sys.setenv(CLASSPATH = "/usr/lib/oracle/ojdbc8.jar")' >> ~/.Rprofile

          # Test the JDBC connection
          Rscript -e '
            library(RJDBC)

            # Print Java version and classpath to debug
            print(system("java -version", intern = TRUE))
            print(Sys.getenv("CLASSPATH"))
            print(Sys.getenv("JAVA_HOME"))

            # Initialize the Oracle driver explicitly
            drv <- JDBC("oracle.jdbc.OracleDriver", "/usr/lib/oracle/ojdbc8.jar")
            print("JDBC driver initialized successfully")

            # Try to connect
            conn <- tryCatch({
              dbConnect(
                drv,
                "jdbc:oracle:thin:@${{ env.ORACLEHOST }}:1521/FREEPDB1",
                "github_ci",
                "github_ci"
              )
            }, error = function(e) {
              print(paste("Connection error:", e$message))
              NULL
            })

            if (!is.null(conn)) {
              print("Successfully connected to Oracle!")
            }

            data <- dplyr::rename_with(iris, ~ toupper(gsub(".", "_", .x, fixed = TRUE)))

            DBI::dbWriteTable(conn, "IRIS", data)

            print(tibble::tibble(DBI::dbReadTable(conn, "IRIS")))

            print(tibble::tibble(DBI::dbReadTable(conn, "IRIS", lossy = TRUE)))

            print(DBI::dbGetQuery(conn, "select dump(4+4) from dual;"))

            print(DBI::dbGetQuery(conn, paste0("SELECT * FROM IRIS")))

            r <- DBI::dbSendQuery(conn, paste0("SELECT * FROM IRIS"))
            print(class(r))

            out <- RJDBC::fetch(r, -1, block=2048L, use.label=TRUE, lossy=TRUE, tz="", posix.ts=TRUE)
            print(tibble::tibble(out))
            DBI::dbClearResult(r)

            r <- DBI::dbSendQuery(conn, paste0("SELECT * FROM IRIS"))
            out <- RJDBC::fetch(r, -1, block=2048L, use.label=TRUE, lossy=FALSE, tz="", posix.ts=TRUE)
            print(tibble::tibble(out))
            DBI::dbClearResult(r)

            res <- DBI::dbSendQuery(conn, paste0("SELECT * FROM IRIS"))
            print(class(res))


            block <- 2048L
            use.label <- TRUE
            lossy <- TRUE
            tz <- ""
            posix.ts=TRUE

            getColumnLabel <- "getColumnLabel"
            cols <- rJava::.jcall(res@md, "I", "getColumnCount")
            block <- as.integer(block)
            if (length(block) != 1L) stop("invalid block size")
            if (cols < 1L) return(NULL)
            l <- vector("list", cols)
            cts <- rep(0L, cols) ## column type (as per JDBC)
            rts <- rep(0L, cols) ## retrieval types (0 = string, 1 = double, 2 = integer, 3 = POSIXct)
            for (i in 1:cols) {
                ## possible retrieval:
                ## getDouble(), getTimestamp() and getString()
                ## [NOTE: getBigDecimal() is native for all numeric() types]
                ## could cehck java.sql.Timestamp which has .getTime() in millis
                cts[i] <- ct <- rJava::.jcall(res@md, "I", "getColumnType", i)
                l[[i]] <- character()
                ## NOTE: this is also needed in dbColumnInfo() - see also JDBC.types
                ## -7 BIT, -6 TINYINT, 5 SMALLINT, 4 INTEGER, -5 BIGINT
                ## 6 FLOAT, 7 REAL, 8 DOUBLE, 2 NUMERIC, 3 DECIMAL
                ## 1 CHAR, 12 VARCHAR, -1 LONGVARCHAR
                ## 91 DATE, 92 TIME, 93 TIMESTAMP
                ## -2 BINARY, -3 VARBINARY, -4 LONGVARBINARY
                ## 0 NULL, 1111 OTHER, 2000 JAVA_OBJECT
                ## 16 BOOLEAN, 1.8+: 2013 TIME_WITH_TIMEZONE,
                ## 2014 TIMESTAMP_WITH_TIMEZONE
                ##
                ## integer-compatible typse
                if (ct == 4L || ct == 5L || ct == -6L) {
                    l[[i]] <- integer()
                    rts[i] <- 2L
                } else if (ct == -5L | (ct >= 2L & ct <= 8L)) { ## BIGINT and various float/num types
                    ## some numeric types may exceed double precision (see #83)
                    ## those must be retrieved as strings
                    ##
                    ## check precision for NUMERIC/DECIMAL
                    cp <- switch(as.character(ct),
                                `2` =, `3` = rJava::.jcall(res@md, "I", "getPrecision", i),
                                `-5`= 20L, ## BIGINT
                                0L)

                    print("cp")
                    print(cp)
                    print("isTRUE(lossy)")
                    print(isTRUE(lossy))
                    print("cp <= 15")
                    print(cp <= 15)
                    if (cp <= 15 || isTRUE(lossy)) { ## safe to retrieve
                        l[[i]] <- numeric()
                        rts[i] <- 1L
                    }
                } else if (ct >= 91L && ct <= 93L && isTRUE(posix.ts)) { ## DATE/TIME/TS
                    l[[i]] <- .POSIXct(numeric(), tz)
                    rts[i] <- 3L
                } else if (ct == -7L) { ## BIT
                    l[[i]] <- logical()
                    rts[i] <- 4L
                }
                names(l)[i] <- rJava::.jcall(res@md, "S", getColumnLabel, i)

                print(".jcall(res@md, \"I\", \"getPrecision\", i)")
                print(rJava::.jcall(res@md, "I", "getPrecision", i))
            }


            print("cts")
            print(cts)

            print("rts")
            print(rts)

            print("l")
            print(l)

            rp <- res@env$pull
            if (is.jnull(rp)) {
              rp <- rJava::.jnew("info/urbanek/Rpackage/RJDBC/JDBCResultPull", rJava::.jcast(res@jr, "java/sql/ResultSet"), rJava::.jarray(as.integer(rts)))
              res@env$pull <- rp
            }
            print("rp")
            print(rp)

            ret.fn <- list( ## retrieval functions for the different types
                function(i) rJava::.jcall(rp, "[Ljava/lang/String;", "getStrings", i),
                function(i) rJava::.jcall(rp, "[D", "getDoubles", i),
                function(i) rJava::.jcall(rp, "[I", "getIntegers", i),
                function(i) rJava::.jcall(rp, "[D", "getDoubles", i),
                function(i) as.logical(rJava::.jcall(rp, "[I", "getIntegers", i)))

            if (n < 0L) { ## infinite pull - collect (using pairlists) & join
              stride <- 32768L  ## start fairly small to support tiny queries and increase later
              while ((nrec <- rJava::.jcall(rp, "I", "fetch", stride, block)) > 0L) {
                for (i in seq.int(cols))
                  l[[i]] <- pairlist(l[[i]], ret.fn[[rts[i] + 1L]](i))
                if (nrec < stride) break
                stride <- 524288L # 512k
              }
              for (i in seq.int(cols)) l[[i]] <- unlist(l[[i]], TRUE, FALSE)
            } else {
              nrec <- rJava::.jcall(rp, "I", "fetch", as.integer(n), block)
              for (i in seq.int(cols)) l[[i]] <- ret.fn[[rts[i] + 1L]](i)
            }

            print("l")
            print(l)


            ## unlisting can strip attrs so do POSIXct at the end for TSs
            ts.col <- rts == 3L
            if (any(ts.col)) for (i in which(ts.col)) l[[i]] <- .POSIXct(l[[i]], tz)
            # as.data.frame is expensive - create it on the fly from the list
            attr(l, "row.names") <- c(NA_integer_, length(l[[1]]))
            class(l) <- "data.frame"
            #.remap.types(l, cts)


            dbDisconnect(conn)
          '
