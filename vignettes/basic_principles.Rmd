---
title: "Basic principles"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic principles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(SCDB)
options("SCDB.log_path" = tempdir())
```

The basic principle of the SCDB package is to enable the user to easily implement and maintain a database of time-versioned data.

In practice, this is done by labelling each record in the data with three additional fields:

* checksum: the md5 hash of the information stored in the record
* from\_ts: the timestamp at which the record was first introduced to the dataset
* until\_ts: the timestamp at which the record was first removed from the dataset

Note: This strategy of time versioning is often called "type 2" history.


The SCDB package provides the function `update_snapshot` to handle the insertion and deactivation of records using this strategy.
It further includes several functions to improve the quality-of-life for working with databases.

A simple example is shown below:

```{r Example}
# First we connect to our data base.
# If this is, e.g., a PostgreSQL data base already running on the machine, connection
# can be done after the configuration of a .pgpass file.
# For this example, we use an on-disk SQLite db to showcase.
conn <- get_connection(drv = RSQLite::SQLite())
# NOTE: Had the PostgreSQL DB been configured, we would not need to pass any args to get_connection()

# Our example data is mtcars with rownames converted to a column and only the first hp column of mtcars
example_data <- dplyr::transmute(mtcars, car = rownames(mtcars), hp)
# If the data does not already live on the remote, we must transfer it
example_data <- dplyr::copy_to(conn, example_data, overwrite = TRUE)

# In this example, we imagine that on day 1, in this case 2020-01-01 11:00:00, our data known to us is
# the first 3 records of mtcars
data <- head(example_data, 3)

# We then store these data in the data base using update_snapshot
invisible(capture.output({  # NOTE: update_snapshot does some printing to terminal
  update_snapshot(.data = data,
                  conn = conn,
                  db_table = "mtcars", # the name of the DB table we want to store the data in
                  timestamp = as.POSIXct("2020-01-01 11:00:00"))
}))

# We can access our data using the `get_table` function
print(get_table(conn, "mtcars"))

# And we can see the time-keeping if we set `include_slice_info = TRUE`
print(get_table(conn, "mtcars", include_slice_info = TRUE))



# Lets say that the next day, our data set is now the first 5 of our example data
data <- head(example_data, 5)

# We then store these data in the data base using update_snapshot
invisible(capture.output({
  update_snapshot(.data = data,
                  conn = conn,
                  db_table = "mtcars", # the name of the DB table we want to store the data in
                  timestamp = as.POSIXct("2020-01-02 12:00:00"))
}))

# We can again access our data using the `get_table` function and see the latest available data
print(get_table(conn, "mtcars"))

# And we can see the time-keeping if we set `include_slice_info = TRUE`
print(get_table(conn, "mtcars", include_slice_info = TRUE))

# Since our data is time-versioned, we can still recover the data as it looked the day before
print(get_table(conn, "mtcars", slice_ts = "2020-01-01 11:00:00"))



# On day 3, we imagine that we have the same 5 records, but one of them is altered slightly
data <- head(example_data, 5) |>
  dplyr::mutate(hp = ifelse(dplyr::row_number() == 1, hp / 2, hp))

# We then store these data in the data base using update_snapshot
invisible(capture.output({
  update_snapshot(.data = data,
                  conn = conn,
                  db_table = "mtcars", # the name of the DB table we want to store the data in
                  timestamp = as.POSIXct("2020-01-03 10:00:00"))
}))

# We can again access our data using the `get_table` function and see that the currently available data
# (with the changed hp value for Mazda RX4)
print(get_table(conn, "mtcars"))


# When slice_ts is set to NULL, the full history of the table is returned
print(get_table(conn, "mtcars", slice_ts = NULL))

# Setting include_slice_info to TRUE also returns the checksum, from_ts and until_ts fields.
# This is most useful when viewing data from a specific point in time
print(get_table(conn, "mtcars", slice_ts = "2020-01-03 06:30:00, include_slice_info = TRUE))
```
