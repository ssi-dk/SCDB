---
title: "Basic principles"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic principles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, results = 'hide'}
library(SCDB)
options("SCDB.log_path" = tempdir())
```

The basic principle of the SCDB package is to enable the user to easily implement and maintain a database of time-versioned data.

In practice, this is done by labeling each record in the data with three additional fields:

* checksum: the md5 hash of the information stored in the record
* from_ts: the timestamp at which the record was introduced to the dataset
* until_ts: the timestamp at which the record was removed from the dataset

Note: This strategy of time versioning is often called "type 2" history.


The SCDB package provides the function `update_snapshot` to handle the insertion and deactivation of records using this strategy, and it further includes several functions to improve the Quality-of-life for working with database data.

Below we illustrate how this looks in practice:

```{r example_conn}
# First we connect to our database.
# If this is, e.g., a PostgreSQL database already running on the machine, connection
# can be done after the configuration of a .pgpass file.
# For this example, we use an on-disk SQLite db to showcase.
conn <- get_connection(drv = RSQLite::SQLite())
# NOTE: Had the PostgreSQL DB been configured, we would not need to pass any args to get_connection()
```

```{r example_data}
# Our example data is mtcars with rownames converted to a column and only the first hp column of mtcars
example_data <- dplyr::transmute(mtcars, car = rownames(mtcars), hp)
# If the data does not already live on the remote, we must transfer it
example_data <- dplyr::copy_to(conn, example_data, overwrite = TRUE)

```

```{r example_1}
# In this example, we imagine that on day 1, in this case 2020-01-01 11:00:00, our data known to us is
# the first 3 records of mtcars
data <- head(example_data, 3)
```

```{r update_snapshot_1, eval = FALSE}
# We then store these data in the database using update_snapshot
update_snapshot(.data = data,
                conn = conn,
                db_table = "mtcars", # the name of the DB table we want to store the data in
                timestamp = as.POSIXct("2020-01-01 11:00:00"))
```
```{r update_snapshot_1_hidden, results = 'hide', echo = FALSE}
# We then store these data in the database using update_snapshot
invisible(capture.output({  # NOTE: update_snapshot does some printing to terminal
  update_snapshot(.data = data,
                  conn = conn,
                  db_table = "mtcars", # the name of the DB table we want to store the data in
                  timestamp = as.POSIXct("2020-01-01 11:00:00"))
}))
```


```{r example_1_results}
# We can access our data using the `get_table` function
print(get_table(conn, "mtcars"))

# And we can see the time-keeping if we set `include_slice_info = TRUE`
print(get_table(conn, "mtcars", include_slice_info = TRUE))
```

```{r example_2}
# Let's say that the next day, our data set is now the first 5 of our example data
data <- head(example_data, 5)
```

```{r update_snapshot_2, eval = FALSE}
# We then store these data in the database using update_snapshot
update_snapshot(.data = data,
                conn = conn,
                db_table = "mtcars", # the name of the DB table we want to store the data in
                timestamp = as.POSIXct("2020-01-02 12:00:00"))
```
```{r update_snapshot_2_hidden, results = 'hide', echo = FALSE}
# We then store these data in the database using update_snapshot
invisible(capture.output({
  update_snapshot(.data = data,
                  conn = conn,
                  db_table = "mtcars", # the name of the DB table we want to store the data in
                  timestamp = as.POSIXct("2020-01-02 12:00:00"))
}))
```

```{r example_2_results}

# We can again access our data using the `get_table` function and see the latest available data
print(get_table(conn, "mtcars"))

# And we can see the time-keeping if we set `include_slice_info = TRUE`
print(get_table(conn, "mtcars", include_slice_info = TRUE))

# Since our data is time-versioned, we can still recover the data as it looked the day before
print(get_table(conn, "mtcars", slice_ts = "2020-01-01 11:00:00"))
```

```{r example_3}
# On day 3, we imagine that we have the same 5 records, but one of them is altered slightly
data <- head(example_data, 5) |>
  dplyr::mutate(hp = ifelse(dplyr::row_number() == 1, hp / 2, hp))
```

```{r update_snapshot_3, eval = FALSE}
# We then store these data in the database using update_snapshot
update_snapshot(.data = data,
                conn = conn,
                db_table = "mtcars", # the name of the DB table we want to store the data in
                timestamp = as.POSIXct("2020-01-03 10:00:00"))
```
```{r update_snapshot_3_hidden, results = 'hide', echo = FALSE}
# We then store these data in the database using update_snapshot
invisible(capture.output({
  update_snapshot(.data = data,
                  conn = conn,
                  db_table = "mtcars", # the name of the DB table we want to store the data in
                  timestamp = as.POSIXct("2020-01-03 10:00:00"))
}))
```

```{r example_3_results}
# We can again access our data using the `get_table` function and see that the currently available data
# (with the changed hp value for Mazda RX4)
print(get_table(conn, "mtcars"))

# To see the full history of our table, we can set `slice_ts = NULL`
print(get_table(conn, "mtcars", slice_ts = NULL))
```
